<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aanu Oshakuade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;500;600&family=Cormorant+Garamond:wght@600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #f8f7f4;
        --ink: #161616;
        --muted: #4b5563;
        --accent: #0f766e;
      }
      body {
        margin: 0;
        background:
          radial-gradient(
            120% 120% at 20% 10%,
            rgba(15, 118, 110, 0.04),
            transparent 38%
          ),
          radial-gradient(
            100% 100% at 80% 0%,
            rgba(15, 118, 110, 0.05),
            transparent 34%
          ),
          var(--bg);
        color: var(--ink);
        font-family:
          "Source Serif 4",
          system-ui,
          -apple-system,
          serif;
        line-height: 1.82;
        letter-spacing: -0.01em;
        min-height: 100vh;
        overflow-x: hidden;
      }
      .wrap {
        max-width: 840px;
        margin: 0 auto;
        padding: 96px 22px 120px;
        position: relative;
        z-index: 1;
      }
      .name {
        font-family: "Cormorant Garamond", "Source Serif 4", serif;
        font-size: clamp(3rem, 6vw, 3.8rem);
        font-weight: 700;
        letter-spacing: -0.03em;
        line-height: 0.96;
        margin: 0;
      }
      .tagline {
        margin-top: 18px;
        color: var(--muted);
        font-size: 1.12rem;
        letter-spacing: 0.01em;
      }
      .section-heading {
        font-size: 0.9rem;
        letter-spacing: 0.24em;
        font-weight: 600;
        text-transform: uppercase;
        color: #6b7280;
        margin: 52px 0 16px;
      }
      .section-heading:first-of-type {
        margin-top: 64px;
      }
      p,
      li {
        font-size: 1.07rem;
      }
      ul {
        margin: 0;
        padding-left: 1.25rem;
      }
      a {
        color: var(--ink);
        text-decoration: none;
        border-bottom: 1px solid transparent;
      }
      a:hover {
        color: var(--accent);
        border-color: rgba(15, 118, 110, 0.35);
      }
      .footer {
        margin-top: 88px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px 28px;
        font-size: 0.93rem;
        color: #6b7280;
      }
      #bg {
        position: fixed;
        inset: 0;
        z-index: 0;
        pointer-events: none;
        filter: drop-shadow(0 12px 24px rgba(0, 0, 0, 0.08));
      }
      .sim-card {
        margin-top: 36px;
        padding: 0.85rem 0.85rem 0.7rem;
        border: 1px solid rgba(22, 22, 22, 0.18);
        border-radius: 0.85rem;
        background: rgba(255, 255, 255, 0.45);
      }
      .sim-card canvas {
        width: 100%;
        height: 312px;
        border-radius: 0.55rem;
        background: rgba(15, 15, 15, 0.035);
        display: block;
        touch-action: none;
        cursor: grab;
      }
      .sim-card canvas:active {
        cursor: grabbing;
      }
      .sim-caption {
        margin-top: 0.55rem;
        color: var(--muted);
        font-size: 0.88rem;
        letter-spacing: 0.01em;
      }
    </style>
  </head>
  <body>
    <canvas id="bg"></canvas>
    <main class="wrap">
      <header>
        <h1 class="name">Aanu Oshakuade</h1>
        <p class="tagline">
          Computer Engineer | Digital Twins | Simulation | Graph Networks |
          Computer Vision | MLOps | Azure AI | Adversarial ML
        </p>
      </header>

      <section>
        <h2 class="section-heading">Now</h2>
        <p>
          i'm building high-performance GPU-accelerated simulation platforms and
          production AI systems focused on computational biology modeling,
          multi-sensor fusion, RF signal processing &amp; DSP, computer vision
          for surveillance, large-scale parallel workloads, and custom FPGA
          acceleration — with a focus on practical acceleration, evaluation
          rigor, and secure cloud deployment.
        </p>
      </section>

      <section>
        <h2 class="section-heading">Background</h2>
        <p>
          B.S. Computer Engineering — Oral Roberts University (2024). Hands-on
          engineer with deep experience in accelerated computing,
          hardware/software co-design, production ML systems, and secure
          infrastructure. Delivered end-to-end computer vision pipelines (retina
          imaging + surveillance), reinforcement learning environments with
          multi-sensor fusion, FPGA accelerators (FFT/DSP), RF signal modulation
          workflows, and GPU-parallel simulations for biological modeling,
          planetary defense, and edge systems.
        </p>
      </section>

      <section>
        <h2 class="section-heading">Interests</h2>
        <div class="grid md:grid-cols-2 gap-x-10 gap-y-5">
          <div>
            digital twins &amp; high-fidelity 3D simulations (computational
            biology, tumor microenvironments, biological modeling)
          </div>
          <div>
            multi-sensor fusion for autonomous systems
            (IMU/GPS/satellite/weather/IoT integration)
          </div>
          <div>
            RF signal detection &amp; DSP (spread-spectrum, demodulation,
            anomaly detection workflows)
          </div>
          <div>
            computer vision for surveillance (edge-native multi-camera tracking,
            YOLO pipelines, real-time annotation &amp; evidence generation)
          </div>
          <div>
            multi-agent reinforcement learning &amp; swarm coordination (drone
            navigation, real-time sim-to-real)
          </div>
          <div>
            accelerated computing: Triton, JAX, CUDA, vLLM, custom FPGA/RTL
            accelerators (FFT, DSP, inference)
          </div>
          <div>
            MLOps &amp; production pipelines (fine-tuning, evaluation, secure
            cloud inference on Azure/AWS)
          </div>
          <div>
            physics-informed neural networks, graph networks, and
            hardware-software co-design at the edge
          </div>
        </div>
      </section>

      <section>
        <h2 class="section-heading">Vision</h2>
        <p>
          we're at a singular point where the convergence of massive compute
          power, multimodal sensing, and physics-grounded modeling is making it
          possible to simulate and reason about complex real-world systems in
          ways that actually match reality.
        </p>
        <p>
          what really gets me is how these technologies are letting engineers
          move fluidly between hardware-level optimization, algorithmic insight,
          and production deployment — turning raw data streams into systems that
          work reliably under real constraints.
        </p>
        <p class="font-medium mt-6">i believe that:</p>
        <ul class="space-y-3">
          <li>
            the most valuable systems are built by people who deeply respect
            every layer — from the physics of the problem all the way through to
            the final inference pipeline.
          </li>
          <li>
            when hardware acceleration, active feedback loops, and simulation
            are thoughtfully integrated, you start solving problems that used to
            feel out of reach.
          </li>
          <li>
            technical depth and practical execution will always matter more than
            hype — the quiet, rigorous work is what actually moves fields
            forward.
          </li>
        </ul>
      </section>

      <div class="sim-card">
        <canvas id="sim3d"></canvas>
        <p class="sim-caption">
          point-cloud field. click or drag to disturb it.
        </p>
      </div>

      <footer class="footer">
        <a
          href="https://www.linkedin.com/in/aanu-oshakuade-26a2002ab"
          target="_blank"
          rel="noopener"
          >LinkedIn</a
        >
        <a href="mailto:aanuoshaks@gmail.com">Email</a>
        <a href="./resume_optimized_Aanu.pdf" target="_blank" rel="noopener"
          >Resume (PDF)</a
        >
      </footer>
    </main>

    <script>
      // Soft halo point cloud with gentle drift
      let scene, camera, renderer, points;
      const particleCount = 14000;
      let positions, velocities, colors;

      function initThree() {
        const canvas = document.getElementById("bg");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          1,
          1200,
        );
        camera.position.z = 58;

        renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);

        const geometry = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        velocities = new Float32Array(particleCount * 3);
        colors = new Float32Array(particleCount * 3);

        const palette = [
          new THREE.Color("#0f766e"), // deep teal
          new THREE.Color("#1f2937"), // charcoal
          new THREE.Color("#6ee7b7"), // soft mint
        ];

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const radius = 24 + Math.random() * 22;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * 0.82;
          positions[i3 + 2] = radius * Math.cos(phi);

          velocities[i3] = (Math.random() - 0.5) * 0.012;
          velocities[i3 + 1] = (Math.random() - 0.5) * 0.012;
          velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;

          const tint = palette[Math.floor(Math.random() * palette.length)];
          colors[i3] = tint.r * (0.7 + Math.random() * 0.25);
          colors[i3 + 1] = tint.g * (0.7 + Math.random() * 0.25);
          colors[i3 + 2] = tint.b * (0.7 + Math.random() * 0.25);
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3),
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: 0.11,
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true,
          opacity: 0.58,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);

        window.addEventListener("resize", onResize);
        animate();
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        const posAttr = points.geometry.attributes.position;
        const arr = posAttr.array;

        for (let i = 0; i < particleCount * 3; i += 3) {
          velocities[i] += (Math.random() - 0.5) * 0.004;
          velocities[i + 1] += (Math.random() - 0.5) * 0.004;
          velocities[i + 2] += (Math.random() - 0.5) * 0.003;

          velocities[i] *= 0.985;
          velocities[i + 1] *= 0.985;
          velocities[i + 2] *= 0.985;

          arr[i] += velocities[i];
          arr[i + 1] += velocities[i + 1];
          arr[i + 2] += velocities[i + 2];
        }

        posAttr.needsUpdate = true;
        points.rotation.y += 0.00022;
        points.rotation.x += 0.00008;
        renderer.render(scene, camera);
      }

      window.addEventListener("load", initThree);
    </script>
    <script>
      (function initPointCloudSim() {
        const canvas = document.getElementById("sim3d");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        const pointer = { x: 0, y: 0, active: false, force: 0 };
        const points = [];
        const cols = 70;
        const rows = 28;
        let width = 0;
        let height = 0;
        let lastTime = performance.now();

        function resize() {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          width = Math.max(600, Math.floor(canvas.clientWidth || 600));
          height = Math.max(280, Math.floor(canvas.clientHeight || 312));
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          points.length = 0;
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const px = (c / (cols - 1)) * width;
              const py = (r / (rows - 1)) * height;
              points.push({
                x: px,
                y: py,
                ox: px,
                oy: py,
                vx: 0,
                vy: 0,
              });
            }
          }
        }

        function setPointer(event) {
          const rect = canvas.getBoundingClientRect();
          pointer.x = event.clientX - rect.left;
          pointer.y = event.clientY - rect.top;
        }

        function onDown(event) {
          pointer.active = true;
          pointer.force = 1.2;
          setPointer(event);
          canvas.setPointerCapture(event.pointerId);
        }

        function onMove(event) {
          setPointer(event);
          if (pointer.active) pointer.force = 1.0;
        }

        function onUp(event) {
          pointer.active = false;
          pointer.force = 0;
          canvas.releasePointerCapture(event.pointerId);
        }

        function step(dt, timeSec) {
          const pull = 6.2;
          const drag = 0.955;
          const spread = 0.038;
          const radius = Math.min(width, height) * 0.2;
          const maxSpeed = 14;
          const maxOffsetX = width * 0.42;
          const maxOffsetY = height * 0.42;
          const recoveryBlend = 0.03;
          const flowStrength = 0.34;

          for (let index = 0; index < points.length; index++) {
            const point = points[index];
            const dxHome = point.ox - point.x;
            const dyHome = point.oy - point.y;
            point.vx += dxHome * pull * dt;
            point.vy += dyHome * pull * dt;

            if (pointer.active) {
              const dx = point.x - pointer.x;
              const dy = point.y - pointer.y;
              const d2 = dx * dx + dy * dy;
              if (d2 < radius * radius) {
                const d = Math.sqrt(d2) || 1;
                const falloff = 1 - d / radius;
                const kick = pointer.force * falloff * 132 * dt;
                point.vx += (dx / d) * kick;
                point.vy += (dy / d) * kick;
              }
            }

            const c = index % cols;
            const r = Math.floor(index / cols);
            if (c > 0) {
              const left = points[index - 1];
              point.vx += (left.x - point.x) * spread;
              point.vy += (left.y - point.y) * spread;
            }
            if (c < cols - 1) {
              const right = points[index + 1];
              point.vx += (right.x - point.x) * spread;
              point.vy += (right.y - point.y) * spread;
            }
            if (r > 0) {
              const up = points[index - cols];
              point.vx += (up.x - point.x) * spread;
              point.vy += (up.y - point.y) * spread;
            }
            if (r < rows - 1) {
              const down = points[index + cols];
              point.vx += (down.x - point.x) * spread;
              point.vy += (down.y - point.y) * spread;
            }

            const nx = point.x / width - 0.5;
            const ny = point.y / height - 0.5;
            const swirl =
              Math.sin(timeSec * 0.75 + nx * 5.5) *
              Math.cos(timeSec * 0.55 + ny * 4.6);
            point.vx += (-ny * flowStrength + swirl * 0.06) * dt * 60;
            point.vy += (nx * flowStrength + swirl * 0.045) * dt * 60;

            if (!Number.isFinite(point.vx) || !Number.isFinite(point.vy)) {
              point.vx = 0;
              point.vy = 0;
            }
            point.vx = Math.max(-maxSpeed, Math.min(maxSpeed, point.vx));
            point.vy = Math.max(-maxSpeed, Math.min(maxSpeed, point.vy));
            point.vx *= drag;
            point.vy *= drag;
            point.x += point.vx;
            point.y += point.vy;

            point.x += (point.ox - point.x) * recoveryBlend;
            point.y += (point.oy - point.y) * recoveryBlend;

            const offX = point.x - point.ox;
            const offY = point.y - point.oy;
            if (
              !Number.isFinite(point.x) ||
              !Number.isFinite(point.y) ||
              Math.abs(offX) > maxOffsetX ||
              Math.abs(offY) > maxOffsetY
            ) {
              point.x = point.ox;
              point.y = point.oy;
              point.vx = 0;
              point.vy = 0;
            }
          }
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);
          const gradient = ctx.createLinearGradient(0, 0, width, height);
          gradient.addColorStop(0, "rgba(11, 109, 102, 0.92)");
          gradient.addColorStop(1, "rgba(34, 98, 201, 0.88)");

          for (let i = 0; i < points.length; i++) {
            const point = points[i];
            const speed = Math.min(
              1,
              Math.hypot(point.vx, point.vy) / 5 + (pointer.active ? 0.06 : 0),
            );
            const radius = 0.8 + speed * 1.8;
            ctx.globalAlpha = 0.28 + speed * 0.62;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }

          if (pointer.active) {
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "rgba(34, 98, 201, 0.55)";
            ctx.beginPath();
            ctx.arc(pointer.x, pointer.y, Math.min(width, height) * 0.07, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.globalAlpha = 1;
        }

        function animate(now) {
          const dt = Math.min(0.033, (now - lastTime) / 1000);
          lastTime = now;
          step(dt, now * 0.001);
          draw();
          requestAnimationFrame(animate);
        }

        canvas.addEventListener("pointerdown", onDown);
        canvas.addEventListener("pointermove", onMove);
        canvas.addEventListener("pointerup", onUp);
        canvas.addEventListener("pointerleave", () => {
          pointer.active = false;
          pointer.force = 0;
        });
        window.addEventListener("resize", resize);

        resize();
        requestAnimationFrame((now) => {
          lastTime = now;
          requestAnimationFrame(animate);
        });
      })();
    </script>
  </body>
</html>
